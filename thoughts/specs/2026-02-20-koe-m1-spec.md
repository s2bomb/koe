---
title: "Koe M1 Requirements Specification"
date: 2026-02-20
author: OpenCode (spec-writer)
status: draft
project: "koe-m1"
source_brief: "thoughts/projects/2026-02-20-koe-m1/sources/project-brief.md"
research_document: "thoughts/projects/2026-02-20-koe-m1/working/project-level-research-architecture.md"
scope: "Milestone 1 only (Terminal Proof of Concept on X11)"
---

# Koe M1 Requirements Specification

## Acceptance Criteria

- [ ] A user can trigger Koe from a global hotkey while a terminal window is focused, speak, stop recording, and receive pasted text in the active terminal input.
- [ ] The runtime flow is on-demand and single-run per invocation: start, record, transcribe, paste, clean up, exit.
- [ ] If no focused window is detected at invocation time, Koe shows a desktop notification and exits without recording.
- [ ] If microphone, CUDA, xdotool, xclip, or notify-send prerequisites are unavailable, Koe shows a clear error notification and exits safely.
- [ ] Transcription for M1 runs on CUDA only; CPU fallback is treated as an error path for this milestone.
- [ ] Clipboard content is restored after successful paste, and temp audio artefacts are removed on all exit paths.
- [ ] Strict type-checking and linting pass using the repository's configured toolchain, and tests cover happy-path plus key failure states.
- [ ] README setup and run instructions are sufficient for a developer to reach first successful transcription in under 15 minutes.

---

## Overview

### Summary

Koe M1 delivers a terminal-focused, global-hotkey voice-to-text workflow on Arch Linux under X11. The user presses a configured hotkey to start recording, presses again to stop, then receives local Whisper transcription pasted into the currently focused terminal input.

M1 is constrained to a procedural, no-persistent-service runtime shape per invocation. It must prioritise deterministic behaviour, explicit side-effect boundaries, strong typing, and safe cleanup of temporary resources.

### Source of Truth

- Primary brief (immutable source): `thoughts/projects/2026-02-20-koe-m1/sources/project-brief.md`
- Project-level research synthesis: `thoughts/projects/2026-02-20-koe-m1/working/project-level-research-architecture.md`
- Project workflow blocker requiring section breakdown: `thoughts/projects/2026-02-20-koe-m1/index.md:15`

### Scope Boundaries (M1)

In scope:
- X11 terminal proof of concept only
- Single-language English transcription
- Clipboard-based insertion via X11 tooling
- Module-level unit tests + one integration flow test

Out of scope:
- Wayland
- Streaming partial transcription
- GUI settings
- Multi-language and custom vocabulary
- Persistent daemon mode

---

## Decision Register (M1 Defaults)

- **Type-checking gate**: M1 uses Pyright strict as canonical, aligned to existing repo config in `pyproject.toml:24`.
- **Hotkey backend**: M1 targets `pynput` backend first, prioritising non-root setup for developer usability.
- **GPU policy**: M1 requires CUDA transcription; if CUDA is not available, run fails with notification (no CPU fallback in this milestone).
- **Success feedback**: M1 includes explicit success/complete user notification in addition to start/processing/error notifications.
- **Concurrency safety**: M1 requires single-instance execution guard to prevent concurrent clipboard and temp-file races.

---

## Section Breakdown

### Section 1: Runtime and Typed Foundations

- [ ] **US-1**: As a developer, I want a flat module skeleton with explicit typed boundaries so that each concern is independently testable and composable.
- [ ] **US-2**: As a developer, I want strict type contracts for pipeline data so that integration errors are caught before runtime.

Acceptance criteria:
- [ ] `src/koe/` contains M1 modules defined by the brief module map (`project-brief.md:112`).
- [ ] Shared types for hotkey events, window focus result, audio artefact path, transcription result, notification kind, and clipboard state are defined centrally.
- [ ] Type-check command is documented and runnable against current project tooling (`pyproject.toml:24`).

### Section 2: X11 Context and Global Trigger

- [ ] **US-3**: As a user, I want a global hotkey trigger so that I can start Koe from any active context.
- [ ] **US-4**: As a user, I want Koe to validate a focused window exists before recording so that it avoids unnecessary recording when no target is available.

Acceptance criteria:
- [ ] A hotkey invocation starts the M1 run loop.
- [ ] If no focused window exists, Koe notifies and exits before any audio capture.
- [ ] A second invocation during an active run does not start a concurrent pipeline.

### Section 3: Audio Capture and Temporary Artefact Lifecycle

- [ ] **US-5**: As a user, I want microphone audio captured at Whisper-compatible settings so that transcription quality is usable for terminal input.
- [ ] **US-6**: As a user, I want recording stop control from hotkey so that I can finish dictation naturally.

Acceptance criteria:
- [ ] Recording captures at 16 kHz float32 and produces a temporary WAV artefact for transcription.
- [ ] Missing microphone or inaccessible audio device yields a visible error notification and safe exit.
- [ ] Temporary audio artefacts are removed after success and after error exits.

### Section 4: Local GPU Transcription

- [ ] **US-7**: As a user, I want local GPU transcription so that speech-to-text remains fast and private.
- [ ] **US-8**: As a user, I want clear handling of unusable transcription output so that I understand when retry is needed.

Acceptance criteria:
- [ ] Transcription executes against CUDA for M1, aligned with hardware requirement (`project-brief.md:27`, `project-brief.md:223`).
- [ ] CUDA unavailable state is surfaced as explicit error with no silent CPU fallback.
- [ ] Empty or whitespace transcription output produces user-visible "no speech detected" feedback and does not paste empty content.

### Section 5: Text Insertion and Clipboard Safety

- [ ] **US-9**: As a user, I want transcribed text inserted into the focused terminal input so that dictation replaces manual typing.
- [ ] **US-10**: As a user, I want my pre-existing clipboard preserved so that Koe does not disrupt unrelated workflows.

Acceptance criteria:
- [ ] Insertion path uses clipboard write + simulated paste strategy (`project-brief.md:84`).
- [ ] Original clipboard text is restored after successful paste.
- [ ] If insertion fails after transcription is produced, user receives recovery guidance (for example, text left available for manual paste) and cleanup still runs.

### Section 6: User Feedback and Error Surfaces

- [ ] **US-11**: As a user, I want clear notifications for each major run state so that I trust what Koe is doing.
- [ ] **US-12**: As a user, I want failures to be explicit and actionable so that I can resolve environment problems quickly.

Acceptance criteria:
- [ ] Notification states include: recording started, processing, completed, and error.
- [ ] Error notifications identify failing subsystem category (focus, audio, CUDA/transcription, insertion, dependency).
- [ ] Notification failures do not crash core runtime flow.

### Section 7: Quality Gates, Tests, and Documentation

- [ ] **US-13**: As a developer, I want automated checks for type safety, linting, and behaviour so that regressions are caught early.
- [ ] **US-14**: As a new contributor, I want setup and run documentation that works end-to-end so that onboarding is fast.

Acceptance criteria:
- [ ] Test suite includes unit coverage for each module boundary and one integration scenario for terminal dictation flow.
- [ ] Test coverage includes key error states: no focused window, missing microphone, CUDA unavailable, insertion tool unavailable.
- [ ] Repository commands for lint/typecheck/test/run are documented and executable.
- [ ] README includes prerequisites and first-run verification path.

---

## Module Contract Summary (M1)

| Module | Required contract (WHAT) |
|---|---|
| `main.py` | Orchestrates linear run lifecycle and centralises cleanup on all exit paths |
| `hotkey.py` | Emits start/stop trigger semantics for one invocation lifecycle |
| `window.py` | Determines focused-window availability gate before record phase |
| `audio.py` | Captures microphone input and yields temp WAV artefact |
| `transcribe.py` | Produces text transcription from temp WAV using local CUDA model |
| `insert.py` | Performs clipboard-safe insertion into focused X11 target |
| `notify.py` | Emits user-visible state and failure notifications |
| `config.py` | Defines immutable M1 defaults (hotkey, model, sample rate, paste key) |
| `types.py` | Defines shared structural types and domain aliases for module boundaries |

---

## Dependencies

| Dependency area | M1 requirement |
|---|---|
| Python runtime | Python 3.12+ (`pyproject.toml:9`) |
| Type/lint baseline | Pyright strict + Ruff rules (`pyproject.toml:24`, `pyproject.toml:37`) |
| System tools | `xdotool`, `xclip`, `notify-send`, PortAudio, CUDA stack (`project-brief.md:204`) |
| Python runtime libs | `faster-whisper`, `sounddevice`, `numpy`, `pynput` (`project-brief.md:213`) |
| Test/dev libs | `pytest`, `typeguard` for test verification (`project-brief.md:104`) |

---

## Out of Scope

- Wayland compositor support
- Cross-application input specificity beyond terminal-first assumptions
- Streaming partial transcript display
- Persistent background service lifecycle
- GUI or interactive settings editor

---

## Developer Notes

Research and codebase-grounded observations:

- Existing implementation is scaffold-only; module behaviours in this spec are net-new requirements (`thoughts/projects/2026-02-20-koe-m1/working/project-level-research-architecture.md:39`).
- Repository currently enforces Pyright strict, not mypy, so M1 type gate aligns to configured toolchain (`pyproject.toml:24`, `thoughts/projects/2026-02-20-koe-m1/working/project-level-research-architecture.md:68`).
- `src/koe/py.typed` exists and should be retained as package typing marker (`src/koe/py.typed`, `thoughts/projects/2026-02-20-koe-m1/working/project-level-research-architecture.md:52`).
- `thoughts/projects/2026-02-20-koe-m1/index.md:15` blocks downstream section execution until an explicit section breakdown exists; this document provides that breakdown.
- `pyproject.toml:10` currently lists only `pydantic`; M1 runtime/test dependency requirements in brief must be reflected during implementation planning (`thoughts/projects/2026-02-20-koe-m1/working/project-level-research-architecture.md:67`).
- Brief mandates clipboard restore and linear cleanup semantics; this spec strengthens those as explicit acceptance outcomes (`project-brief.md:84`, `project-brief.md:80`).

## Perspective Analysis Summary

Alignment (high confidence):
- Greenfield module implementation is feasible with existing scaffold and strict tooling baseline.
- Clipboard integrity, cleanup guarantees, and explicit error surfaces are mandatory for a trustworthy M1 user experience.
- Sectioned delivery across foundations, trigger, capture, transcription, insertion, feedback, and quality gates matches both brief and research findings.

Divergence resolved for M1 in this spec:
- mypy vs pyright: resolved to Pyright strict for M1 to match current repository configuration.
- CUDA fallback policy: resolved to fail-fast on non-CUDA availability to satisfy milestone acceptance clarity.
- Success-state feedback: resolved to include explicit completed notification for clearer UX closure.

---

## Open Questions (Non-blocking for section planning)

- [ ] Should `pydantic` remain a runtime dependency for M1 config validation, or be removed to honour minimal dependency goals?
- [ ] Should M1 support configurable alternate paste keystrokes (for terminals needing `Ctrl+Shift+V`) inside the initial section scope, or as a follow-up patch?
- [ ] Should binary/non-text clipboard restoration be explicitly handled in M1, or documented as a known limitation with text-only guarantee?
